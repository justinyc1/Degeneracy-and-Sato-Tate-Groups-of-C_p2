"""
description -- This program computes the moment statistics for p = 7 (m = 49). For m = 49, sympy integration was used as
               it proved to be more efficient. The integrands come from the a1 coefficients that we computed (see the
               "a1_coeffs" folder).

               Refer to the folder labeled "moment_stats" for the data generated by this program.

"""

#USING SYMPY INTEGRATION

from sympy import symbols, cos, pi, integrate, simplify, expand
import numpy as np

def compute_primary_integral(n):
    """Generates a function which is the integrand used for the b = 0 case. Computes and returns result of integral."""
    theta = symbols('theta1:22')  # creates theta1 to theta21, indexes will be one off

    integrand = sum(cos(t) for t in theta)
    integrand += cos(-theta[0] + theta[5] + theta[6] - theta[7] + theta[12] - theta[14] + theta[19])
    integrand += cos(-theta[1] + theta[4] - theta[8] + theta[11] + theta[13] - theta[15] + theta[18])
    integrand += cos(-theta[2] + theta[3] - theta[9] + theta[10] - theta[16] + theta[17] + theta[20])

    integrand_power = integrand**n

    for t in reversed(theta):
        integrand_power = integrate(integrand_power, (t, 0, 2 * pi))

    return simplify(integrand_power)


def compute_secondary_integral(n):
    """Generates a function which is the integrand used for all b nonzero cases. Computes and returns result of integral."""
    theta7, theta14, theta21 = symbols('theta7 theta14 theta21')

    integrand = (cos(theta7) + cos(theta14) + cos(theta21))**n
    integrand = expand(integrand)
    integrand = integrate(integrand, (theta7, 0, 2 * pi))
    integrand = integrate(integrand, (theta14, 0, 2 * pi))
    integrand = integrate(integrand, (theta21, 0, 2 * pi))
    return simplify(integrand)


def main():
    p = 7
    normal_relations = ((p ** 2 - 1) // 2) - ((p - 1) // 2)
    total_moment_stats = []

    for b in range(p*(p-1)):
        print(f"b = {b}: ", end = "")
        moment_stats = [1]

        if b == 0:
            moment_stats = [1]
            for n in range(1, 9):
                if n % 2 != 0:
                    moment_stats.append(0)
                    continue
                result = compute_primary_integral(n)
                result *= ((2 ** n) / ((2 * pi) ** normal_relations))
                moment_stats.append(result)
            print()
            total_moment_stats.append(moment_stats)
        elif b % 6 == 0:
            for n in range(1, 9):
                if n % 2 != 0:
                    moment_stats.append(0)
                    continue
                result = compute_secondary_integral(n)
                result *= ((2 ** n) / ((2 * pi)**3))
                moment_stats.append(result)
            total_moment_stats.append(moment_stats)
        else:
            for n in range(1, 9):
                moment_stats.append(0)
            total_moment_stats.append(moment_stats)

    for item in total_moment_stats:
        print(f"{item} \n")

    arr = np.array(total_moment_stats)
    column_averages = np.mean(arr, axis=0)
    print([f"{x}" for x in column_averages])


main()
