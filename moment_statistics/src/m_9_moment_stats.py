"""
description -- This program computes the moment statistics for p = 3 (m = 9). For m = 9, scipy integration was used as
               it proved to be more efficient.

               Refer to the folder labeled "outputs" for the data generated by this program.
"""

# USING SCIPY INTEGRATION
import numpy as np
from scipy import integrate


# m = 9, p = 3
def generate_primary_integrand(n):
    """Generates and returns a function which is the integrand used for the b = 0 case."""
    def integrand(theta1, theta2, theta3):
        return (np.cos(theta1) + np.cos(theta2) + np.cos(theta3) + np.cos(-theta1 + theta2 + theta3))**n
    return integrand

def generate_secondary_integrand(n):
    """Generates and returns a function which is the integrand used for all b nonzero cases."""
    def function(theta3):
        return np.cos(theta3)**n
    return function

def main():
    p = 3
    num_normal_relations = ((p ** 2 - 1) // 2) - ((p - 1) // 2)
    total_moment_stats = []
    for b in range(6):
        moment_stats = [1]
        if b == 0:
            for n in range(1, 13):
                if n % 2 != 0:
                    moment_stats.append(0)
                    continue
                integrand = generate_primary_integrand(n)
                limits = [(0, 2*np.pi), (0, 2*np.pi), (0, 2*np.pi)]
                result, _ = integrate.nquad(integrand, limits)
                result *= ((2 ** n) / ((2 * np.pi) ** num_normal_relations))
                moment_stats.append(result)
            total_moment_stats.append(moment_stats)
        elif b%2 != 0:
            for n in range(1, 13):
                moment_stats.append(0)
            total_moment_stats.append(moment_stats)
        elif b==2:
            for n in range(1, 13):
                if n%2 != 0:
                    moment_stats.append(0)
                    continue
                integrand = generate_secondary_integrand(n)
                limits = [(0, 2*np.pi)]
                result, _ = integrate.nquad(integrand, limits)
                result *= (2 ** n) / (2 * np.pi)
                moment_stats.append(result)
            total_moment_stats.append(moment_stats)
        else:
            for n in range(1, 13):
                if n%2 != 0:
                    moment_stats.append(0)
                    continue
                integrand = generate_secondary_integrand(n)
                limits = [(0, 2*np.pi)]
                result, _ = integrate.nquad(integrand, limits)
                result *= ((-2) ** n) / (2 * np.pi)
                moment_stats.append(result)
            total_moment_stats.append(moment_stats)

    for item in total_moment_stats:
        print(f"{item} \n")

    arr = np.array(total_moment_stats)
    column_averages = np.mean(arr, axis=0)
    print([f"{x}" for x in column_averages])


main()