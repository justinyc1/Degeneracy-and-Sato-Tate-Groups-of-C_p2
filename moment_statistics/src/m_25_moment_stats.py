"""
description -- This program computes the moment statistics for p = 5 (m = 25). For m = 25, sympy integration was used as
               it proved to be more efficient. The integrands come from the a1 coefficients that we computed (see the
               "a1_coeffs" folder).

               Refer to the folder labeled "moment_stats" for the data generated by this program.

"""

#USING SYMPY INTEGRATION

from sympy import symbols, cos, pi, integrate, simplify, expand
import numpy as np

def compute_primary_integral(n):
    """Generates a function which is the integrand used for the b = 0 case. Computes and returns result of integral."""
    theta = symbols('theta1:11')  # creates theta1 to theta10, indexes will be one off

    integrand = sum(cos(t) for t in theta)
    integrand += cos(-theta[0] + theta[3] + theta[4] - theta[5] + theta[8])
    integrand += cos(-theta[1] + theta[2] - theta[6] + theta[7] + theta[9])

    integrand_power = integrand**n

    for t in reversed(theta):
        integrand_power = integrate(integrand_power, (t, 0, 2 * pi))
        integrand_power = simplify(integrand_power)

    return simplify(integrand_power)


def compute_secondary_integral(n):
    """Generates a function which is the integrand used for all b nonzero cases. Computes and returns result of integral."""
    theta5, theta10 = symbols('theta5 theta10')

    integrand = (cos(theta5) + cos(theta10))**n
    integrand = expand(integrand)
    integrand = integrate(integrand, (theta5, 0, 2 * pi))
    integrand = integrate(integrand, (theta10, 0, 2 * pi))
    return simplify(integrand)


def main():
    p = 5
    num_normal_relations = ((p ** 2 - 1) // 2) - ((p - 1) // 2)
    total_moment_stats = []

    for b in range(20):
        print(f"b = {b} :", end = "")
        moment_stats = [1]

        if b == 0:
            moment_stats = [1]
            for n in range(1, 13):
                if n % 2 != 0:
                    moment_stats.append(0)
                    continue
                result = compute_primary_integral(n)
                result *= ((2 ** n) / ((2 * pi) ** num_normal_relations))
                moment_stats.append(result)
            total_moment_stats.append(moment_stats)
        elif b % 4 == 0:
            for n in range(1, 13):
                if n % 2 != 0:
                    moment_stats.append(0)
                    continue
                result = compute_secondary_integral(n)
                result *= (2 ** n) / ((2 * pi)**2)
                moment_stats.append(result)
            total_moment_stats.append(moment_stats)
        else:
            for n in range(1, 13):
                moment_stats.append(0)
            total_moment_stats.append(moment_stats)

    for item in total_moment_stats:
        print(f"{item} \n")

    arr = np.array(total_moment_stats)
    column_averages = np.mean(arr, axis=0)
    print([f"{x}" for x in column_averages])


main()